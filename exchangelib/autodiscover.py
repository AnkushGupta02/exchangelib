# coding=utf-8
"""
Autodiscover is a Microsoft method for automatically getting the hostname of the Exchange server and the server
version of the server holding the email address using only the email address and password of the user (and possibly
User Principal Name). The protocol for autodiscovering an email address is described in detail in
https://docs.microsoft.com/en-us/previous-versions/office/developer/exchange-server-interoperability-guidance. Handling
error messages is described here:
https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/handling-autodiscover-error-messages.
This is not fully implemented.

WARNING: We are taking many shortcuts here, like assuming TLS and following 302 Redirects automatically.
If you have problems autodiscovering, start by doing an official test at https://testconnectivity.microsoft.com
"""
from __future__ import unicode_literals

from contextlib import contextmanager
import getpass
import glob
import logging
import os
import shelve
import sys
import tempfile
from threading import Lock

import dns.resolver
from future.utils import raise_from, PY2, python_2_unicode_compatible
from six import text_type

from . import transport
from .configuration import Configuration
from .credentials import BaseCredentials
from .errors import AutoDiscoverFailed, AutoDiscoverRedirect, AutoDiscoverCircularRedirect, TransportError, \
    RedirectError, ErrorNonExistentMailbox, UnauthorizedError
from .fields import TextField, EmailAddressField, ChoiceField, Choice, EWSElementField, OnOffField, BooleanField, \
    IntegerField, BuildField, ProtocolListField
from .properties import EWSElement
from .protocol import BaseProtocol, Protocol, RetryPolicy, FailFast
from .transport import DEFAULT_ENCODING, DEFAULT_HEADERS
from .util import create_element, add_xml_child, to_xml, is_xml, post_ratelimited, xml_to_str, \
    get_domain, AUTODISCOVER_BASE_NS, AUTODISCOVER_REQUEST_NS, AUTODISCOVER_RESPONSE_NS as RNS

log = logging.getLogger(__name__)


def shelve_filename():
    # Add the version of the cache format to the filename. If we change the format of the cached data, this version
    # must be bumped. Otherwise, new versions of this package cannot open cache files generated by older versions.
    version = 2
    # 'shelve' may pickle objects using different pickle protocol versions. Append the python major+minor version
    # numbers to the filename. Also append the username, to avoid permission errors.
    major, minor = sys.version_info[:2]
    try:
        user = getpass.getuser()
    except KeyError:
        # getuser() fails on some systems. Provide a sane default. See issue #448
        user = 'exchangelib'
    return 'exchangelib.{version}.cache.{user}.py{major}{minor}'.format(
        version=version, user=user, major=major, minor=minor
    )


AUTODISCOVER_PERSISTENT_STORAGE = os.path.join(tempfile.gettempdir(), shelve_filename())


@contextmanager
def shelve_open_with_failover(filename):
    # We can expect empty or corrupt files. Whatever happens, just delete the cache file and try again.
    # 'shelve' may add a backend-specific suffix to the file, so also delete all files with a suffix.
    # We don't know which file caused the error, so just delete them all.
    try:
        shelve_handle = shelve.open(filename)
    except Exception as e:
        for f in glob.glob(filename + '*'):
            log.warning('Deleting invalid cache file %s (%r)', f, e)
            os.unlink(f)
        shelve_handle = shelve.open(filename)
    yield shelve_handle
    if PY2:
        shelve_handle.close()


@python_2_unicode_compatible
class AutodiscoverCache(object):
    """Stores the translation from (email domain, credentials) -> AutodiscoverProtocol object so we can re-use TCP
    connections to an autodiscover server within the same process. Also persists the email domain -> (autodiscover
    endpoint URL, auth_type) translation to the filesystem so the cache can be shared between multiple processes.

    According to Microsoft, we may forever cache the (email domain -> autodiscover endpoint URL) mapping, or until
    it stops responding. My previous experience with Exchange products in mind, I'm not sure if I should trust that
    advice. But it could save some valuable seconds every time we start a new connection to a known server. In any
    case, the persistent storage must not contain any sensitive information since the cache could be readable by
    unprivileged users. Domain, endpoint and auth_type are OK to cache since this info is make publicly available on
    HTTP and DNS servers via the autodiscover protocol. Just don't persist any credentials info.

    If an autodiscover lookup fails for any reason, the corresponding cache entry must be purged.

    'shelve' is supposedly thread-safe and process-safe, which suits our needs.
    """
    def __init__(self):
        self._protocols = {}  # Mapping from (domain, credentials) to AutodiscoverProtocol

    @property
    def _storage_file(self):
        return AUTODISCOVER_PERSISTENT_STORAGE

    def clear(self):
        # Wipe the entire cache
        with shelve_open_with_failover(self._storage_file) as db:
            db.clear()
        self._protocols.clear()

    def __contains__(self, key):
        domain = key[0]
        with shelve_open_with_failover(self._storage_file) as db:
            return str(domain) in db

    def __getitem__(self, key):
        protocol = self._protocols.get(key)
        if protocol:
            return protocol
        domain, credentials = key
        with shelve_open_with_failover(self._storage_file) as db:
            endpoint, auth_type, retry_policy = db[str(domain)]  # It's OK to fail with KeyError here
        protocol = AutodiscoverProtocol(config=Configuration(
            service_endpoint=endpoint, credentials=credentials, auth_type=auth_type, retry_policy=retry_policy
        ))
        self._protocols[key] = protocol
        return protocol

    def __setitem__(self, key, protocol):
        # Populate both local and persistent cache
        domain = key[0]
        with shelve_open_with_failover(self._storage_file) as db:
            # Don't change this payload without bumping the cache file version in shelve_filename()
            db[str(domain)] = (protocol.service_endpoint, protocol.auth_type, protocol.retry_policy)
        self._protocols[key] = protocol

    def __delitem__(self, key):
        # Empty both local and persistent cache. Don't fail on non-existing entries because we could end here
        # multiple times due to race conditions.
        domain = key[0]
        with shelve_open_with_failover(self._storage_file) as db:
            try:
                del db[str(domain)]
            except KeyError:
                pass
        try:
            del self._protocols[key]
        except KeyError:
            pass

    def close(self):
        # Close all open connections
        for (domain, _), protocol in self._protocols.items():
            log.debug('Domain %s: Closing sessions', domain)
            protocol.close()
            del protocol
        self._protocols.clear()

    def __del__(self):
        # pylint: disable=bare-except
        try:
            self.close()
        except Exception:  # nosec
            # __del__ should never fail
            pass

    def __str__(self):
        return text_type(self._protocols)


_autodiscover_cache = AutodiscoverCache()
_autodiscover_cache_lock = Lock()


def close_connections():
    _autodiscover_cache.close()


def discover(email, credentials=None, auth_type=None, retry_policy=None):
    """
    Performs the autodiscover dance and returns the primary SMTP address of the account and a Protocol on success. The
    autodiscover and EWS server might not be the same, so we use a different Protocol to do the autodiscover request,
    and return a hopefully-cached Protocol to the callee.
    """
    log.debug('Attempting autodiscover on email %s', email)
    if not isinstance(credentials, (BaseCredentials, type(None))):
        raise ValueError("'credentials' %r must be a Credentials instance" % credentials)
    if not isinstance(retry_policy, (RetryPolicy, type(None))):
        raise ValueError("'retry_policy' %r must be a RetryPolicy instance" % retry_policy)
    domain = get_domain(email)
    # We may be using multiple different credentials and changing our minds on TLS verification. This key combination
    # should be safe.
    autodiscover_key = (domain, credentials)
    # Use lock to guard against multiple threads competing to cache information
    log.debug('Waiting for _autodiscover_cache_lock')
    with _autodiscover_cache_lock:
        # Don't recurse while holding the lock!
        log.debug('_autodiscover_cache_lock acquired')
        if autodiscover_key in _autodiscover_cache:
            protocol = _autodiscover_cache[autodiscover_key]
            if not isinstance(protocol, AutodiscoverProtocol):
                raise ValueError('Unexpected autodiscover cache contents: %s' % protocol)
            # Reset auth type and retry policy if we requested non-default values
            if auth_type:
                protocol.config.auth_type = auth_type
            if retry_policy:
                protocol.config.retry_policy = retry_policy
            log.debug('Cache hit for domain %s credentials %s: %s', domain, credentials, protocol.service_endpoint)
            try:
                # This is the main path when the cache is primed
                return _autodiscover_quick(credentials=credentials, email=email, protocol=protocol)
            except AutoDiscoverFailed:
                # Autodiscover no longer works with this domain. Clear cache and try again after releasing the lock
                del _autodiscover_cache[autodiscover_key]
            except AutoDiscoverRedirect as e:
                log.debug('%s redirects to %s', email, e.redirect_email)
                if email.lower() == e.redirect_email.lower():
                    raise_from(AutoDiscoverCircularRedirect('Redirect to same email address: %s' % email), None)
                # Start over with the new email address after releasing the lock
                email = e.redirect_email
        else:
            log.debug('Cache miss for domain %s credentials %s', domain, credentials)
            log.debug('Cache contents: %s', _autodiscover_cache)
            try:
                # This eventually fills the cache in _autodiscover_hostname
                return _try_autodiscover(hostname=domain, credentials=credentials, email=email,
                                         auth_type=auth_type, retry_policy=retry_policy)
            except AutoDiscoverRedirect as e:
                if email.lower() == e.redirect_email.lower():
                    raise_from(AutoDiscoverCircularRedirect('Redirect to same email address: %s' % email), None)
                log.debug('%s redirects to %s', email, e.redirect_email)
                # Start over with the new email address after releasing the lock
                email = e.redirect_email
    log.debug('Released autodiscover_cache_lock')
    # We fell out of the with statement, so either cache was filled by someone else, or autodiscover redirected us to
    # another email address. Start over after releasing the lock.
    return discover(email=email, credentials=credentials, auth_type=auth_type, retry_policy=retry_policy)


def _try_autodiscover(hostname, credentials, email, auth_type, retry_policy):
    # Implements the full chain of autodiscover server discovery attempts. Tries to return autodiscover data from the
    # final host.
    try:
        return _autodiscover_hostname(hostname=hostname, credentials=credentials, email=email, has_ssl=True,
                                      auth_type=auth_type, retry_policy=retry_policy)
    except RedirectError as e:
        if not e.has_ssl:
            raise_from(AutoDiscoverFailed(
                '%s redirected us to %s but only HTTPS redirects allowed' % (hostname, e.url)
            ), None)
        log.info('%s redirected us to %s', hostname, e.server)
        return _try_autodiscover(hostname=e.server, credentials=credentials, email=email, auth_type=auth_type,
                                 retry_policy=retry_policy)
    except AutoDiscoverFailed as e:
        log.info('Autodiscover on %s failed (%s). Trying autodiscover.%s', hostname, e, hostname)
        try:
            return _autodiscover_hostname(hostname='autodiscover.%s' % hostname, credentials=credentials, email=email,
                                          has_ssl=True, auth_type=auth_type, retry_policy=retry_policy)
        except RedirectError as e:
            if not e.has_ssl:
                raise_from(AutoDiscoverFailed(
                    'autodiscover.%s redirected us to %s but only HTTPS redirects allowed' % (hostname, e.url)
                ), None)
            log.info('%s redirected us to %s', hostname, e.server)
            return _try_autodiscover(hostname=e.server, credentials=credentials, email=email,
                                     auth_type=auth_type, retry_policy=retry_policy)
        except AutoDiscoverFailed:
            log.info('Autodiscover on %s failed (%s). Trying autodiscover.%s (plain HTTP)', hostname, e, hostname)
            try:
                return _autodiscover_hostname(hostname='autodiscover.%s' % hostname, credentials=credentials,
                                              email=email, has_ssl=False, auth_type=auth_type,
                                              retry_policy=retry_policy)
            except RedirectError as e:
                if not e.has_ssl:
                    raise_from(AutoDiscoverFailed(
                        'autodiscover.%s redirected us to %s but only HTTPS redirects allowed' % (hostname, e.url)
                    ), None)
                log.info('autodiscover.%s redirected us to %s', hostname, e.server)
                return _try_autodiscover(hostname=e.server, credentials=credentials, email=email,
                                         auth_type=auth_type, retry_policy=retry_policy)
            except AutoDiscoverFailed as e:
                log.info('Autodiscover on autodiscover.%s (no TLS) failed (%s). Trying DNS records', hostname, e)
                hostname_from_dns = _get_canonical_name(hostname='autodiscover.%s' % hostname)
                try:
                    if not hostname_from_dns:
                        log.info('No canonical name on autodiscover.%s Trying SRV record', hostname)
                        hostname_from_dns = _get_hostname_from_srv(hostname='autodiscover.%s' % hostname)
                    # Start over with new hostname
                    return _try_autodiscover(hostname=hostname_from_dns, credentials=credentials, email=email,
                                             auth_type=auth_type, retry_policy=retry_policy)
                except AutoDiscoverFailed as e:
                    log.info('Autodiscover on %s failed (%s). Trying _autodiscover._tcp.%s', hostname_from_dns, e,
                             hostname)
                    # Start over with new hostname
                    try:
                        hostname_from_dns = _get_hostname_from_srv(hostname='_autodiscover._tcp.%s' % hostname)
                        return _try_autodiscover(hostname=hostname_from_dns, credentials=credentials, email=email,
                                                 auth_type=auth_type, retry_policy=retry_policy)
                    except AutoDiscoverFailed:
                        raise_from(AutoDiscoverFailed('All steps in the autodiscover protocol failed'), None)


def _get_auth_type_or_raise(url, email, hostname, retry_policy):
    # Returns the auth type of the URL. Raises any redirection errors. This tests host DNS, port availability, and TLS
    # validation (if applicable).
    try:
        return _get_auth_type(url=url, email=email, retry_policy=retry_policy)
    except RedirectError as e:
        redirect_url, redirect_hostname, redirect_has_ssl = e.url, e.server, e.has_ssl
        log.debug('We were redirected to %s', redirect_url)
        if redirect_hostname.startswith('www.'):
            # Try the process on the new host, without 'www'. This is beyond the autodiscover protocol and an attempt to
            # work around seriously misconfigured Exchange servers. It's probably better to just show the Exchange
            # admins the report from https://testconnectivity.microsoft.com
            redirect_hostname = redirect_hostname[4:]
        canonical_hostname = _get_canonical_name(redirect_hostname)
        if canonical_hostname:
            log.debug('Canonical hostname is %s', canonical_hostname)
            redirect_hostname = canonical_hostname
        if redirect_hostname == hostname:
            log.debug('We were redirected to the same host')
            raise_from(AutoDiscoverFailed('We were redirected to the same host'), None)
        raise_from(RedirectError(url='%s://%s' % ('https' if redirect_has_ssl else 'http', redirect_hostname)), None)


def _autodiscover_hostname(hostname, credentials, email, has_ssl, auth_type, retry_policy):
    # Tries to get autodiscover data on a specific host. If we are HTTP redirected, we restart the autodiscover dance on
    # the new host.
    url = '%s://%s/Autodiscover/Autodiscover.xml' % ('https' if has_ssl else 'http', hostname)
    log.info('Trying autodiscover on %s', url)
    if not is_valid_hostname(hostname):
        # 'requests' is really bad at reporting that a hostname cannot be resolved. Let's check this separately.
        raise_from(AutoDiscoverFailed('%r has no DNS entry' % hostname), None)
    # We are connecting to an unknown server here. It's probable that servers in the autodiscover sequence are
    # unresponsive or send any kind of ill-formed response. We shouldn't use a retry policy meant for a trusted
    # endpoint here.
    initial_retry_policy = AutodiscoverProtocol.INITIAL_RETRY_POLICY
    if auth_type is None:
        auth_type = _get_auth_type_or_raise(url=url, email=email, hostname=hostname, retry_policy=initial_retry_policy)
    autodiscover_protocol = AutodiscoverProtocol(config=Configuration(
        service_endpoint=url, credentials=credentials, auth_type=auth_type, retry_policy=initial_retry_policy
    ))
    r = _get_response(protocol=autodiscover_protocol, email=email)
    domain = get_domain(email)
    try:
        ews_url, primary_smtp_address = _parse_response(r.content)
        if not primary_smtp_address:
            primary_smtp_address = email
    except (ErrorNonExistentMailbox, AutoDiscoverRedirect):
        # These are both valid responses from an autodiscover server, showing that we have found the correct
        # server for the original domain. Fill cache before re-raising
        log.debug('Adding cache entry for %s (hostname %s)', domain, hostname)
        # We have already acquired the cache lock at this point
        _autodiscover_cache[(domain, credentials)] = autodiscover_protocol
        raise

    # Cache the final hostname of the autodiscover service so we don't need to autodiscover the same domain again
    log.debug('Adding cache entry for %s (hostname %s, has_ssl %s)', domain, hostname, has_ssl)
    # We have already acquired the cache lock at this point
    _autodiscover_cache[(domain, credentials)] = autodiscover_protocol
    # Autodiscover response contains an auth type, but we don't want to spend time here testing if it actually works.
    # Instead of forcing a possibly-wrong auth type, just let Protocol auto-detect the auth type.
    return primary_smtp_address, Protocol(config=Configuration(
        service_endpoint=ews_url, credentials=credentials, auth_type=None, retry_policy=retry_policy
    ))


def _autodiscover_quick(credentials, email, protocol):
    r = _get_response(protocol=protocol, email=email)
    ews_url, primary_smtp_address = _parse_response(r.content)
    if not primary_smtp_address:
        primary_smtp_address = email
    log.debug('Autodiscover success: %s may connect to %s as primary email %s', email, ews_url, primary_smtp_address)
    # Autodiscover response contains an auth type, but we don't want to spend time here testing if it actually works.
    # Instead of forcing a possibly-wrong auth type, just let Protocol auto-detect the auth type.
    return primary_smtp_address, Protocol(config=Configuration(
        service_endpoint=ews_url, credentials=credentials, auth_type=None, retry_policy=protocol.retry_policy
    ))


def _get_payload(email):
    # Builds a full Autodiscover XML request
    payload = create_element('Autodiscover', attrs=dict(xmlns=AUTODISCOVER_REQUEST_NS))
    request = create_element('Request')
    add_xml_child(request, 'EMailAddress', email)
    add_xml_child(request, 'AcceptableResponseSchema', RNS)
    payload.append(request)
    return xml_to_str(payload, encoding=DEFAULT_ENCODING, xml_declaration=True)


def _get_auth_type(url, email, retry_policy):
    try:
        data = _get_payload(email=email)
        return transport.get_autodiscover_authtype(service_endpoint=url, retry_policy=retry_policy, data=data)
    except TransportError as e:
        if isinstance(e, RedirectError):
            raise
        raise_from(AutoDiscoverFailed('Error guessing auth type: %s' % e), None)


def _get_response(protocol, email):
    data = _get_payload(email=email)
    try:
        # Rate-limiting is an issue with autodiscover if the same setup is hosting EWS and autodiscover and we just
        # hammered the server with requests. We allow redirects since some autodiscover servers will issue different
        # redirects depending on the POST data content.
        session = protocol.get_session()
        r, session = post_ratelimited(protocol=protocol, session=session, url=protocol.service_endpoint,
                                      headers=DEFAULT_HEADERS.copy(), data=data, allow_redirects=True)
        protocol.release_session(session)
        log.debug('Response headers: %s', r.headers)
    except RedirectError:
        raise
    except (TransportError, UnauthorizedError):
        log.debug('No access to %s using %s', protocol.service_endpoint, protocol.auth_type)
        raise_from(
            AutoDiscoverFailed('No access to %s using %s' % (protocol.service_endpoint, protocol.auth_type)), None
        )
    if not is_xml(r.content):
        # This is normal - e.g. a greedy webserver serving custom HTTP 404's as 200 OK
        log.debug('URL %s: This is not XML: %r', protocol.service_endpoint, r.content[:1000])
        raise AutoDiscoverFailed('URL %s: This is not XML: %r' % (protocol.service_endpoint, r.content[:1000]))
    return r


def _parse_response(bytes_content):
    # We could return lots more interesting things here
    try:
        autodiscover = AutodiscoverElement.from_bytes(bytes_content=bytes_content)
    except ValueError as e:
        raise AutoDiscoverFailed(str(e))
    if autodiscover.response is None:
        try:
            autodiscover.raise_errors()
        except ValueError as e:
            raise AutoDiscoverFailed(str(e))
    if autodiscover.redirect_address:
        # This is redirection to e.g. Office365
        raise AutoDiscoverRedirect(autodiscover.redirect_address)
    try:
        ews_url = autodiscover.protocol.ews_url
    except ValueError:
        raise AutoDiscoverFailed('No valid protocols in response: %s' % bytes_content)
    if not ews_url:
        raise ValueError("Required element 'EwsUrl' not found in response")
    log.debug('Primary SMTP: %s, EWS endpoint: %s', autodiscover.autodiscover_smtp_address, ews_url)
    return ews_url, autodiscover.autodiscover_smtp_address


def is_valid_hostname(hostname):
    log.debug('Checking if %s can be looked up in DNS', hostname)
    resolver = dns.resolver.Resolver()
    resolver.timeout = AutodiscoverProtocol.TIMEOUT
    try:
        resolver.query(hostname)
    except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer):
        return False
    return True


def _get_canonical_name(hostname):
    log.debug('Attempting to get canonical name for %s', hostname)
    resolver = dns.resolver.Resolver()
    resolver.timeout = AutodiscoverProtocol.TIMEOUT
    try:
        canonical_name = resolver.query(hostname).canonical_name.to_unicode().rstrip('.')
    except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer):
        log.debug('Nonexistent domain %s', hostname)
        return None
    if canonical_name != hostname:
        log.debug('%s has canonical name %s', hostname, canonical_name)
        return canonical_name
    return None


def _get_hostname_from_srv(hostname):
    # An SRV entry may contain e.g.:
    #   canonical name = mail.ucl.dk.
    #   service = 8 100 443 webmail.ucn.dk.
    # or throw dns.resolver.NoAnswer
    # The first three numbers in the service line are priority, weight, port
    log.debug('Attempting to get SRV record on %s', hostname)
    resolver = dns.resolver.Resolver()
    resolver.timeout = AutodiscoverProtocol.TIMEOUT
    try:
        answers = resolver.query(hostname, 'SRV')
        for rdata in answers:
            try:
                vals = rdata.to_text().strip().rstrip('.').split(' ')
                # pylint: disable=expression-not-assigned
                int(vals[0]), int(vals[1]), int(vals[2])  # Just to raise errors if these are not ints
                svr = vals[3]
                return svr
            except (ValueError, IndexError):
                raise_from(
                    AutoDiscoverFailed('Incompatible SRV record for %s (%s)' % (hostname, rdata.to_text())), None
                )
    except dns.resolver.NoNameservers:
        raise_from(AutoDiscoverFailed('No name servers for %s' % hostname), None)
    except dns.resolver.NoAnswer:
        raise_from(AutoDiscoverFailed('No SRV record for %s' % hostname), None)
    except dns.resolver.NXDOMAIN:
        raise_from(AutoDiscoverFailed('Nonexistent domain %s' % hostname), None)


@python_2_unicode_compatible
class AutodiscoverProtocol(BaseProtocol):
    """Protocol which implements the bare essentials for autodiscover"""
    TIMEOUT = 10  # Seconds
    # When connecting to servers that may not be serving the correct endpoint, we should use a retry policy that does
    # not leave us hanging for a long time on each step in the protocol.
    INITIAL_RETRY_POLICY = FailFast()

    def __str__(self):
        return '''\
Autodiscover endpoint: %s
Auth type: %s''' % (
            self.service_endpoint,
            self.auth_type,
        )


class AutodiscoverBase(EWSElement):
    NAMESPACE = RNS


class User(AutodiscoverBase):
    """MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/user-pox"""
    ELEMENT_NAME = 'User'
    FIELDS = [
        TextField('display_name', field_uri='DisplayName', namespace=RNS),
        TextField('legacy_dn', field_uri='LegacyDN', namespace=RNS),
        TextField('deployment_id', field_uri='DeploymentId', namespace=RNS),  # GUID format
        EmailAddressField('autodiscover_smtp_address', field_uri='AutoDiscoverSMTPAddress', namespace=RNS),
    ]
    __slots__ = tuple(f.name for f in FIELDS)


class IntExtUrlBase(AutodiscoverBase):
    FIELDS = [
        TextField('external_url', field_uri='ExternalUrl', namespace=RNS),
        TextField('internal_url', field_uri='InternalUrl', namespace=RNS),
    ]
    __slots__ = tuple(f.name for f in FIELDS)


class AddressBook(IntExtUrlBase):
    """MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/addressbook-pox"""
    ELEMENT_NAME = 'AddressBook'
    __slots__ = tuple()


class MailStore(IntExtUrlBase):
    ELEMENT_NAME = 'MailStore'
    __slots__ = tuple()


class NetworkRequirements(AutodiscoverBase):
    """MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/networkrequirements-pox"""
    ELEMENT_NAME = 'NetworkRequirements'
    FIELDS = [
        TextField('ipv4_start', field_uri='IPv4Start', namespace=RNS),
        TextField('ipv4_end', field_uri='IPv4End', namespace=RNS),
        TextField('ipv6_start', field_uri='IPv6Start', namespace=RNS),
        TextField('ipv6_end', field_uri='IPv6End', namespace=RNS),
    ]
    __slots__ = tuple(f.name for f in FIELDS)


class SimpleProtocolElement(AutodiscoverBase):
    """MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/protocol-pox

    Used for the 'Internal' and 'External' elements that may contain a stripped-down version of the Protocol element.
    """
    ELEMENT_NAME = 'Protocol'
    FIELDS = [
        ChoiceField('type', field_uri='Type', choices={
            Choice('WEB'), Choice('EXCH'), Choice('EXPR'), Choice('EXHTTP')
        }, namespace=RNS),
        TextField('as_url', field_uri='ASUrl', namespace=RNS),
    ]
    __slots__ = tuple(f.name for f in FIELDS)


class IntExtBase(AutodiscoverBase):
    FIELDS = [
        # TODO: 'OWAUrl' also has an AuthenticationMethod enum-style XML attribute
        TextField('owa_url', field_uri='OWAUrl', namespace=RNS),
        EWSElementField('protocol', value_cls=SimpleProtocolElement),
    ]
    __slots__ = tuple(f.name for f in FIELDS)


class Internal(IntExtBase):
    """MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/internal-pox"""
    ELEMENT_NAME = 'Internal'
    __slots__ = tuple()


class External(IntExtBase):
    """MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/external-pox"""
    ELEMENT_NAME = 'External'
    __slots__ = tuple()


class ProtocolElement(AutodiscoverBase):
    """MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/protocol-pox"""
    ELEMENT_NAME = 'Protocol'
    TYPES = ('WEB', 'EXCH', 'EXPR', 'EXHTTP')
    FIELDS = [
        # Attribute 'Type' is ignored here. Has a name conflict with the child element and does not seem useful.
        TextField('version', field_uri='Version', is_attribute=True, namespace=RNS),
        ChoiceField('type', field_uri='Type', namespace=RNS, choices={Choice(p) for p in TYPES}),
        TextField('internal', field_uri='Internal', namespace=RNS),
        TextField('external', field_uri='External', namespace=RNS),
        IntegerField('ttl', field_uri='TTL', namespace=RNS, default=1),  # TTL for this autodiscover response, in hours
        TextField('server', field_uri='Server', namespace=RNS),
        TextField('server_dn', field_uri='ServerDN', namespace=RNS),
        BuildField('server_version', field_uri='ServerVersion', namespace=RNS),
        TextField('mdb_dn', field_uri='MdbDN', namespace=RNS),
        TextField('public_folder_server', field_uri='PublicFolderServer', namespace=RNS),
        IntegerField('port', field_uri='Port', namespace=RNS, min=1, max=65535),
        IntegerField('directory_port', field_uri='DirectoryPort', namespace=RNS, min=1, max=65535),
        IntegerField('referral_port', field_uri='ReferralPort', namespace=RNS, min=1, max=65535),
        TextField('as_url', field_uri='ASUrl', namespace=RNS),
        TextField('ews_url', field_uri='EwsUrl', namespace=RNS),
        TextField('emws_url', field_uri='EmwsUrl', namespace=RNS),
        TextField('sharing_url', field_uri='SharingUrl', namespace=RNS),
        TextField('ecp_url', field_uri='EcpUrl', namespace=RNS),
        TextField('ecp_url_um', field_uri='EcpUrl-um', namespace=RNS),
        TextField('ecp_url_aggr', field_uri='EcpUrl-aggr', namespace=RNS),
        TextField('ecp_url_mt', field_uri='EcpUrl-mt', namespace=RNS),
        TextField('ecp_url_ret', field_uri='EcpUrl-ret', namespace=RNS),
        TextField('ecp_url_sms', field_uri='EcpUrl-sms', namespace=RNS),
        TextField('ecp_url_publish', field_uri='EcpUrl-publish', namespace=RNS),
        TextField('ecp_url_photo', field_uri='EcpUrl-photo', namespace=RNS),
        TextField('ecp_url_tm', field_uri='EcpUrl-tm', namespace=RNS),
        TextField('ecp_url_tm_creating', field_uri='EcpUrl-tmCreating', namespace=RNS),
        TextField('ecp_url_tm_hiding', field_uri='EcpUrl-tmHiding', namespace=RNS),
        TextField('ecp_url_tm_editing', field_uri='EcpUrl-tmEditing', namespace=RNS),
        TextField('ecp_url_extinstall', field_uri='EcpUrl-extinstall', namespace=RNS),
        TextField('oof_url', field_uri='OOFUrl', namespace=RNS),
        TextField('oab_url', field_uri='OABUrl', namespace=RNS),
        TextField('um_url', field_uri='UMUrl', namespace=RNS),
        TextField('ews_partner_url', field_uri='EwsPartnerUrl', namespace=RNS),
        TextField('login_name', field_uri='LoginName', namespace=RNS),
        OnOffField('domain_required', field_uri='DomainRequired', namespace=RNS),
        TextField('domain_name', field_uri='DomainName', namespace=RNS),
        OnOffField('spa', field_uri='SPA', namespace=RNS, default=True),
        ChoiceField('auth_package', field_uri='AuthPackage', namespace=RNS, choices={
            Choice(c) for c in ('basic', 'kerb', 'kerbntlm', 'ntlm', 'certificate', 'negotiate', 'nego2')
        }),
        TextField('cert_principal_name', field_uri='CertPrincipalName', namespace=RNS),
        OnOffField('ssl', field_uri='SSL', namespace=RNS, default=True),
        OnOffField('auth_required', field_uri='AuthRequired', namespace=RNS, default=True),
        OnOffField('use_pop_path', field_uri='UsePOPAuth', namespace=RNS),
        OnOffField('smtp_last', field_uri='SMTPLast', namespace=RNS, default=False),
        EWSElementField('network_requirements', value_cls=NetworkRequirements),
        EWSElementField('address_book', value_cls=AddressBook),
        EWSElementField('mail_store', value_cls=MailStore),
    ]
    __slots__ = tuple(f.name for f in FIELDS)


class Error(EWSElement):
    """MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/error-pox"""
    ELEMENT_NAME = 'Error'
    NAMESPACE = AUTODISCOVER_BASE_NS
    FIELDS = [
        TextField('id', field_uri='Id', namespace=AUTODISCOVER_BASE_NS, is_attribute=True),
        TextField('time', field_uri='Time', namespace=AUTODISCOVER_BASE_NS, is_attribute=True),
        TextField('code', field_uri='ErrorCode', namespace=AUTODISCOVER_BASE_NS, is_required=True),
        TextField('message', field_uri='Message', namespace=AUTODISCOVER_BASE_NS, is_required=True),
        TextField('debug_data', field_uri='DebugData', namespace=AUTODISCOVER_BASE_NS),
    ]
    __slots__ = tuple(f.name for f in FIELDS)


class Account(AutodiscoverBase):
    """MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/account-pox"""
    ELEMENT_NAME = 'Account'
    REDIRECT_URL = 'redirectUrl'
    REDIRECT_ADDR = 'redirectAddr'
    SETTINGS = 'settings'
    ACTIONS = (REDIRECT_URL, REDIRECT_ADDR, SETTINGS)
    FIELDS = [
        ChoiceField('type', field_uri='AccountType', namespace=RNS, choices={Choice('email')}),
        ChoiceField('action', field_uri='Action', namespace=RNS, choices={Choice(p) for p in ACTIONS}),
        BooleanField('microsoft_online', field_uri='MicrosoftOnline', namespace=RNS),
        TextField('redirect_url', field_uri='RedirectURL', namespace=RNS),
        EmailAddressField('redirect_address', field_uri='RedirectAddr', namespace=RNS),
        TextField('image', field_uri='Image', namespace=RNS),  # Path to image used for branding
        TextField('service_home', field_uri='ServiceHome', namespace=RNS),  # URL to website of ISP
        ProtocolListField('protocols'),
        # 'SmtpAddress' is inside the 'PublicFolderInformation' element
        TextField('public_folder_smtp_address', field_uri='SmtpAddress', namespace=RNS),
    ]
    __slots__ = tuple(f.name for f in FIELDS)

    @classmethod
    def from_xml(cls, elem, account):
        kwargs = {}
        public_folder_information = elem.find('{%s}PublicFolderInformation' % cls.NAMESPACE)
        for f in cls.FIELDS:
            if f.name == 'public_folder_smtp_address':
                if public_folder_information is None:
                    continue
                kwargs[f.name] = f.from_xml(elem=public_folder_information, account=account)
                continue
            kwargs[f.name] = f.from_xml(elem=elem, account=account)
        cls._clear(elem)
        return cls(**kwargs)


class Response(AutodiscoverBase):
    """MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/response-pox"""
    ELEMENT_NAME = 'Response'
    FIELDS = [
        EWSElementField('user', value_cls=User),
        EWSElementField('account', value_cls=Account),
    ]
    __slots__ = tuple(f.name for f in FIELDS)


class ErrorResponse(EWSElement):
    """MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/response-pox

    Like 'Response', but with a different namespace.
    """
    ELEMENT_NAME = 'Response'
    NAMESPACE = AUTODISCOVER_BASE_NS
    FIELDS = [
        EWSElementField('error', value_cls=Error),
    ]
    __slots__ = tuple(f.name for f in FIELDS)


class AutodiscoverElement(EWSElement):
    ELEMENT_NAME = 'Autodiscover'
    NAMESPACE = AUTODISCOVER_BASE_NS
    FIELDS = [
        EWSElementField('response', value_cls=Response),
        EWSElementField('error_response', value_cls=ErrorResponse),
    ]
    __slots__ = tuple(f.name for f in FIELDS)

    @staticmethod
    def _clear(elem):
        # Parent implementation also clears the parent, but this element doesn't have one.
        elem.clear()

    @classmethod
    def from_bytes(cls, bytes_content):
        """An Autodiscover request and response example is available at:
        https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/pox-autodiscover-response-for-exchange
        """
        if not is_xml(bytes_content):
            raise ValueError('Response is not XML: %s' % bytes_content)
        try:
            root = to_xml(bytes_content).getroot()
        except ParseError:
            raise ValueError('Error parsing XML: %s' % bytes_content)
        if root.tag != cls.response_tag():
            raise ValueError('Unknown root element in XML: %s' % bytes_content)
        return cls.from_xml(elem=root, account=None)

    @property
    def redirect_address(self):
        try:
            if self.response.account.action != Account.REDIRECT_ADDR:
                return None
            return self.response.account.redirect_address
        except AttributeError:
            return None

    @property
    def redirect_url(self):
        try:
            if self.response.account.action != Account.REDIRECT_URL:
                return None
            return self.response.account.redirect_url
        except AttributeError:
            return None

    @property
    def autodiscover_smtp_address(self):
        # AutoDiscoverSMTPAddress might not be present in the XML. In this case, use the original email address.
        try:
            if self.response.account.action != Account.SETTINGS:
                return None
            return self.response.user.autodiscover_smtp_address
        except AttributeError:
            return None

    @property
    def protocol(self):
        # There are three possible protocol types: EXCH, EXPR and WEB.
        # EXPR is meant for EWS. See
        # https://techcommunity.microsoft.com/t5/Exchange-Team-Blog/The-Autodiscover-Service-and-Outlook-Providers-how-does-this/ba-p/584403
        # We allow fallback to EXCH if EXPR is not available, to support installations where EXPR is not available.
        protocols = {p.type: p for p in self.response.account.protocols}
        try:
            return protocols.get('EXPR', protocols['EXCH'])
        except KeyError:
            # Neither type was found. Give up
            raise ValueError('No valid protocols in response')

    def raise_errors(self):
        # Find an error message in the response and raise the relevant exception
        try:
            errorcode = self.error_response.error.code
            message = self.error_response.error.message
            if message in ('The e-mail address cannot be found.', "The email address can't be found."):
                raise ErrorNonExistentMailbox('The SMTP address has no mailbox associated with it')
            raise ValueError('Unknown error %s: %s' % (errorcode, message))
        except AttributeError:
            raise ValueError('Unknown autodiscover error response: %s' % self)
